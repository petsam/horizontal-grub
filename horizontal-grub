#!/bin/bash
#####################################################################
## ===================== Disclaimer ============================== ##
## This script-program is a proof-of-concept project and           ##
## a self training playground on Bash scripting.                   ##
## It is free for copy and use, while I am not responsible for any ##
## damage on your software or hardware. Use at your own risk!      ##
## It would be kind if you report any possible bugs, or ideas for  ##
## smart improvement of current code logic and possible new        ##
## features that are relevant.                                     ##
## =============================================================== ##

#####################################################################
##                    horizontal-grub                              ##
## This script will transform the current grub configuration file  ##
## generated by grub, to a fake-horizontal style.                  ##
## It would be more useful if it was accompannied with a           ##
## relevant and suitable theme.                                    ##
## There is a theme as a work in progress, which will be           ##
## a possible template for theme developers to create some more.   ##
## =============================================================== ##
#####           petsam's "Adventures in Bash"                   #####
#####################################################################

HGVersion="0.1.0"
# Default parameter values

MaxHGBackups="1"
ShowActivity="false"
SaveGrubcfg=""

# TODO Unnecessary Special character in Grub entry REPORT at Manjaro grub
# TODO consider a grub patch to have better distro names-labels in menus

# Help message
HorizontalMenuHelp="$0 Version: $HGVersion
horizontal-grub transforms the current grub configuration file generated by grub, to a fake-horizontal style
    Usage:
    -V|--version     Prints the program version
    -h|--help        This help information message
    -b|--backup NUM  Delete previous backup files, keeping only NUM backups. (Default=1)
    -f|--grub-file PATH  PATH is the full or relative path to a custom grub.cfg file.
                     If the parameter is not used, /boot/gru/grub.cfg is used
    -s|--save TARGET Saves the produced grub.cfg file to TARGET without confirmation
                     TARGET values are 'system' (save at /boot/grub/grub.cfg)
                       or 'local' (save at TMPDIR i.e. /tmp/horizontal-grub-xxxxxx/grub.cfg)
    -v|--verbose     Shows detailed activity information
    "
# Check for given command line parameters
if [ $# -ge 1 ]; then
	while [ "${1+defined}" ]; do
		case "$1" in
			-h|--help) echo -e "$HorizontalMenuHelp" ; exit;;
			-V|--version) echo $0 Version: $HGVersion ; exit;;
			-v|--verbose) ShowActivity="true"
				shift
				;;
			-s|--save) shift
				if [[ "$1" = "system" ]] || [[ "$1" = "local" ]]; then
					SaveGrubcfg="$1"
				else
					echo "Invalid argument for --save parameter"
					echo -e "$HorizontalMenuHelp" ; exit
				fi
				shift
				;;
			-b|--backup) shift
				if [[ $1 =~ [0-9] ]]; then
					MaxHGBackups="$1"
					shift
				else
					echo "Invalid argument for Maximum Backups"
					echo -e "$HorizontalMenuHelp" ; exit
				fi
				;;
			-f|--grub-file) shift
				if [ "${1+defined}" ] && [ ! "${1#-}" = "-" ]; then
					GrubcfgPath="$1"
					shift
				else
					echo "No file was provided. Exiting..."
					echo -e "$HorizontalMenuHelp"
					exit
				fi
				;;
			*)	echo "Unknown argument $1"
				echo "Exiting..."
				exit
				;;
		esac
	done
fi

if (( $(id -u) == 0 )); then
	IAMROOT="true"
else
    [ "$ShowActivity" = "true" ] && echo "You should run this script as root to save your new grub configuration"
fi

if [ ! ${GrubcfgPath+defined} ]; then
	GrubcfgPath="/boot/grub/grub.cfg"
else
	if [ ! ${GrubcfgPath:0:1} = "/" ]; then
		if [ "$IAMROOT" = "true" ];then
			GrubcfgPath=$(sudo -E pwd)/"$GrubcfgPath"
		else
			GrubcfgPath=$(pwd)/"$GrubcfgPath"
		fi
	fi
fi
[ "$ShowActivity" = "true" ] && echo Provided file is $GrubcfgPath
#if [ $(stat -c "%U" $GrubcfgPath) = $(whoami) ]; then
#	FileReadable=true
#elif [ $(echo $(groups) | grep -c $(stat -c "%G" $GrubcfgPath)) = 1 ] && [ ${$(stat -c "%a" $GrubcfgPath):-2:1} >= 4 ]; then
#	FileReadable=true
#elif [ $(echo $(groups) | grep -c "wheel") = 1 ]; then
#	echo "File is not owned by you, but you are the administrator."
#	FileReadable=false
#else
#	echo "The file is not readable, or you have not permission to read"
#	exit;
#fi

if [ -r $GrubcfgPath ]; then
	[ "$ShowActivity" = "true" ] && echo "The provided file is readable"
elif [ -f $GrubcfgPath ] && [ ! -r $GrubcfgPath ]; then
	echo "The provided file is not readable. You need to be root."
	echo "Exiting"
	exit 1;
else
	echo "The provided file could not be found."
	echo "Exiting"
	exit 127;
fi

HorizontalMenuHeading="
#### Trasformed grub menu to pseudo-horizontal by horizontal-grub ####
"
[ "$ShowActivity" = "true" ] && echo "Transforming " $GrubcfgPath
# Create work directory
DateSuffix=$(date +%s)
WorkDir=${TMPDIR:-/tmp/}horizontal-grub-"$DateSuffix"
mkdir -p "$WorkDir"
cd $WorkDir
GrubcfgAttrs=$(stat -c "%a" /boot/grub/grub.cfg)
[ "$ShowActivity" = "true" ] && echo Attributes are: $GrubcfgAttrs
cp "$GrubcfgPath" grub.cfg
if [ ! $? ]; then echo "An error occured on file copy action. Exiting" ; exit 128; fi

if (( $(cat grub.cfg | grep -cF "#### Trasformed grub menu to pseudo-horizontal by horizontal-grub ####") >= 1 )); then
	echo "This grub configuration is already transformed by horizontal-menu."
	echo "Exiting..."
	rm -R "$WorkDir"
	exit 1;
fi

[ "$ShowActivity" = "true" ] && echo "Created working directory :" "$WorkDir"

# Split sections

cat grub.cfg | grep -Fm 1 -B 2000 "### BEGIN /etc/grub.d/10_linux ###" > horizontal-grub.cfg
cat grub.cfg | grep -Fm 1 -A 2000 "### BEGIN /etc/grub.d/10_linux ###" | grep -Fm 1 -B 2000 "### END /etc/grub.d/10_linux ###" | grep -nv ^# | tr " " "^" > maindistro.cfg
cat grub.cfg | grep -Fm 1 -A 2000 "### BEGIN /etc/grub.d/30_os-prober ###" | grep -Fm 1 -B 2000 "### END /etc/grub.d/30_os-prober ###" | grep -nv ^# | tr " " "^" > osprobed.cfg

function NoMultiboot {
MultiBooter=$(cat osprobed.cfg | grep -cE "\:submenu|\:menuentry" 2>/dev/null)
if [ $MultiBooter -eq 0 ]; then
	echo "There was no other system configured by grub. You are not multibooting."
	echo "There is no reason to use this script. Exiting..."
	rm -R "$WorkDir"
	exit;
fi
}
# Define Parse function

function ParseDistros {
	if [ $# = 0 ]; then
		echo "Not grub compatible data in the file. Something is wrong. Exiting..."
		return 1
	elif [ $# = 1 ]; then
		echo "No distro configuration found. Something went wrong. Exiting..."
		return 1
	fi

	# Parse passed arguments
	local EntriesType="$1"
	shift
	local -a DistroSections
	SentDBs=$#
	for (( i=0; i<$SentDBs; i++ ))
		do
			DistroSections[$i]=$1
			shift
		done

	AlienEntries="false"
	if [ $EntriesType = "AlienDistros" ]; then
		EntriesType="osprobed.cfg"
		AlienEntries="true"
	fi
	# Get distro menus borders

	ProbedEntry=0
	IsParsable=1
	IsAlien=1
	for EntryBorder in ${DistroSections[@]}
		do
			CurrEntry="$(echo $EntryBorder | grep -woE "submenu|menuentry|}")"
			#echo "Current Entry" $CurrEntry
			if [ "$CurrEntry" = "menuentry" ]; then
				if [  "$EntriesType" = "osprobed.cfg" ] ; then
					if [  $(echo $EntryBorder | grep -icwE "windows|osx|hurd|gnuhurd") -ge 1 ] ; then
						EntryStart[$ProbedEntry]=$(echo $EntryBorder | cut -d ":" -f1)
						## TODO add feature to edit Alien Distros names
						MainName[$ProbedEntry]=$(echo $EntryBorder |  awk -F "'" '{  print $2 }')
						IsAlien=0
						IsParsable=0
					else
						#MainEntry[$ProbedEntry]=$(echo $EntryBorder | cut -d ":" -f1)
						## TODO add feature to remove Linux from Linux Distros names
						MainName[$ProbedEntry]=$(echo $EntryBorder |  awk -F "'" '{  print $2 }')
						IsParsable=1
					fi
					## TODO add feature to remove Linux from Linux class names for icon discovery
					MainClass[$ProbedEntry]=$(echo $EntryBorder | awk -F "--" '{  print $2 }')
					EntryAlien[$ProbedEntry]=$IsAlien
				elif [ "$EntriesType" = "maindistro.cfg" ]; then
					## TODO add feature to remove Linux from Linux class names for icon discovery
					MainDistroClass=$(echo $EntryBorder | awk -F "--" '{  print $2 }')
					MainClass[$ProbedEntry]=$MainDistroClass
					## TODO add feature to remove Linux from Linux Distros names
					MainName[$ProbedEntry]=$(echo $EntryBorder |  awk -F "'" '{  print $2 }')
					IsParsable=1
				fi
			elif [ "$CurrEntry" = "submenu" ]; then
				EntryStart[$ProbedEntry]=$(echo $EntryBorder | cut -d ":" -f1)
				EntryAlien[$ProbedEntry]=$IsAlien
				IsParsable=0
			else
				if [ $IsParsable -eq 0 ]; then
					EntryEnd[$ProbedEntry]=$(echo $EntryBorder | cut -d ":" -f1)
					LastBracketLine=${EntryEnd[$ProbedEntry]}
					((ProbedEntry+=1))
				fi
				EntryAlien[$ProbedEntry]=$IsAlien
				IsParsable=1
				IsAlien=1
			fi
		done
	#echo "Entry start" ${EntryStart[@]}
	#echo "Entry end  " ${EntryEnd[@]}
	# Remove main distro class
	if [ "$EntriesType" = "maindistro.cfg" ]; then
		sed -i '/menuentry\^/ s/\-\-'$MainDistroClass'//g' "$EntriesType"
	fi

	# Advanced submenu entries
	if [ "$EntriesType" = "maindistro.cfg" ]; then
		EntryOut=1
	elif [ "$EntriesType" = "osprobed.cfg" ]; then
		EntryOut=0
		if [ $AlienEntries = "false" ]; then
			for StartLine in ${EntryStart[@]}
				do
					if [ ${EntryAlien[$EntryOut]} -eq 1 ]  ; then
						MainEntryName="\^\^\>\>\>\>\^\^"${MainName[$EntryOut]}
						cat "$EntriesType" | grep "^${StartLine}\:" | awk -F "'" -v OFS="'" -v mainentry="$MainEntryName" ' { print $1, mainentry, $3, $4, $5 }' 2>/dev/null | cut -d ":" -f2,3,4 | tr "^" " " >> horizontal-grub.cfg
					fi
					((EntryOut+=1))
				done
		fi
	fi

# Distro menu sections

if [ $AlienEntries = "false" ]; then
		[ "$ShowActivity" = "true" ] && echo "Looking into " $EntriesType"..."
	until [ $EntryOut = 0 ]
		do
			((EntryOut-=1))
			if [ ${EntryAlien[$EntryOut]} -eq 1 ]  ; then
				RStartLine=${EntryStart[$EntryOut]}
				EntryLines=${EntryEnd[$EntryOut]}
				[ "$ShowActivity" = "true" ] && echo "Found " $(echo  ${MainClass[$EntryOut]} | cut -d\^ -f2) "  " $(echo  ${MainName[$EntryOut]} | tr "^" " ")
				((RStartLine+=1))
				((EntryLines-=$RStartLine))
				if [ "$EntriesType" = "maindistro.cfg" ]; then
				((EntryLines-=2))
				fi
				cat "$EntriesType" | grep "^$RStartLine\:" |  sed 's/class\^gnu-linux\^/'${MainClass[$EntryOut]}'\-\-class\^gnu-linux\^/g' | cut -d ":" -s -f 2,3,4 | tr "^" " "  >> horizontal-grub.cfg
				((RStartLine+=1))
				cat "$EntriesType" | grep -A ${EntryLines} "^$RStartLine\:" | cut -d ":" -s -f 2,3,4 | tr "^" " "  >> horizontal-grub.cfg
			fi
		done
elif [ $AlienEntries = "true" ]; then
	[ "$ShowActivity" = "true" ] && echo "Looking for Aliens..."
	for entry in ${EntryStart[@]} ;
	do
		if [ ${EntryAlien[$EntryOut]} -eq 0 ]  ; then
			RStartLine=${EntryStart[$EntryOut]}
			EntryLines=${EntryEnd[$EntryOut]}
			echo "Found " $(echo  ${MainClass[$EntryOut]} | cut -d\^ -f2) "  " $(echo  ${MainName[$EntryOut]} | tr "^" " ")
			cat "$EntriesType" | grep "^$RStartLine\:" |  sed 's/'${MainClass[$EntryOut]}'\-\-//g' | cut -d ":" -s -f 2,3,4 | tr "^" " "  >> horizontal-grub.cfg
			((RStartLine+=1))
			((EntryLines-=$RStartLine))
			cat "$EntriesType" | grep -A ${EntryLines} "^$RStartLine\:" | cut -d ":" -s -f 2,3,4 | tr "^" " "  >> horizontal-grub.cfg
		fi
		((EntryOut+=1))
	done
fi
unset
}

# Define menu entries vars

OSproberDistros=$(cat osprobed.cfg | grep -E "\:submenu|\:menuentry|\:}")
MainDistro=$(cat maindistro.cfg | grep -E "\:submenu|\:menuentry|\:}")
HasAlien=$(grep -icwE "windows|osx|darwin|hurd|gnuhurd" osprobed.cfg)
if (( $HasAlien >= 1 )) ; then
	[ "$ShowActivity" = "true" ] && echo "Found " $HasAlien " Alien entries : " $(grep -woE "windows|osx|hurd|gnuhurd" osprobed.cfg)
	AlienDistros="true"
else
	AlienDistros="false"
fi
if (( $HasAlien >= 3 )); then
	while true; do
		read -p "It looks like an Alien invasion! Would you like to contain them in a separate page?
		[Y]es [N]o : " AlienBox
		case $AlienBox in
			[Yy]) echo "This feature is not implemented yet. Please make a request to the developer."
				sleep 3s
				break ;;
			[Nn]) echo "Fine by me. It's easier. Just watch them out!"
				sleep 3s
				break ;;
			*) echo "   Answer [Y]es or [N]o. Is your keyboard broken?" ;;

		esac
	done

fi
# Add information message for grub transformation

echo $HorizontalMenuHeading >> horizontal-grub.cfg

# Call parse function

ParseDistros "osprobed.cfg" ${OSproberDistros[@]}
OsProberLastLine=$LastBracketLine
ParseDistros "maindistro.cfg" ${MainDistro[@]}
if [ $AlienDistros = "true" ]; then
	ParseDistros "AlienDistros" ${OSproberDistros[@]}
	OsProberLastLine=$LastBracketLine
fi
((OsProberLastLine+=1))
cat osprobed.cfg | grep -A 2000 "^$OsProberLastLine\:" | cut -d ":" -s -f 2,3,4 | tr "^" " "  >> horizontal-grub.cfg;
cat grub.cfg | grep -Fm 1 -A 2000 "### END /etc/grub.d/30_os-prober ###" >> horizontal-grub.cfg;

if [ -s horizontal-grub.cfg ]; then
	echo "The new configuration file is created as "$WorkDir"/horizontal-grub.cfg"
	while [ "$SaveGrubcfg" = "" ]; do
		read -p "Do you want to save it as your current /boot/grub/grub.cfg, ($MaxHGBackups backup(s) will be kept)?
				[Y]es [N]o : " SaveGrubcfg

		[ "$ShowActivity" = "true" ] && echo Answer is $SaveGrubcfg
		case $SaveGrubcfg in
		[Yy]) SaveGrubcfg="system" ; break ;;
		[Nn]) SaveGrubcfg="local" ; echo " The new configuration file is saved at "$WorkDir"/grub.cfg"
				echo "You may use this command to save at system (a backup will be saved)"
				echo "sudo cp -b --suffix .hg-"$DateSuffix" "$WorkDir"/horizontal-grub.cfg /boot/grub/grub.cfg "
				break ;;
			*) echo "   Answer [Y]es or [N]o. You will keep the file locally, if you answer 'No'" ;;
		esac
	done
	if [ "$SaveGrubcfg" = "system" ]; then
		[ "$ShowActivity" = "true" ] && echo "Copying to system..."
		chmod $GrubcfgAttrs horizontal-grub.cfg
		sudo cp -b --suffix .hg-"$DateSuffix" "$WorkDir"/horizontal-grub.cfg /boot/grub/grub.cfg
		GrubCopied=$?

		if [ $GrubCopied ]; then
			HGBackups=($(ls -1t  /boot/grub/ | grep -E "grub.cfg.[0-9]*|grub.cfg.hg-[0-9]*"))
			[ "$ShowActivity" = "true" ] && echo "${#HGBackups[*]} backups were found."
			[ "$ShowActivity" = "true" ] && echo "${HGBackups[*]}"
			for (( Del=$((${#HGBackups[*]})) ; Del>=$MaxHGBackups ; Del-- )) ; do
				[ ! x"${HGBackups[$Del]}" = "x" ]  && sudo rm /boot/grub/"${HGBackups[$Del]}"
				done
			[ "$ShowActivity" = "true" ] && ls -1lt  /boot/grub/ | grep -E "grub.cfg.[0-9]*|grub.cfg.hg-[0-9]*"
			[ "$ShowActivity" = "true" ] && echo "The new horizontal-menu grub layout was successfully copied to system!
	Happy grubing!!"
		else
			echo "Unfortunately the file failed to be copied to system"
			echo "Exiting..."
			exit;
		fi
	fi
else
	echo "There were errors and the grub configuration could not be created."
	echo "If you think this is a bug, please report it to the script author."
fi

exit